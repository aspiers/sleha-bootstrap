#!/bin/bash
#
# Copyright (c) 2010 Novell Inc., Tim Serong <tserong@novell.com>
#                        All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
#

. /usr/lib/hae-functions

usage()
{
	cat <<END
Usage: $0 [options] [stage]

Options:
    -h          Display this usage information
    -i          Default to IP address on interface 'if' instead of eth0
    -q          Be quiet (don't describe what's happening, just do it)
    -y          Answer "yes" to all prompts (use with care)

Stage can be one of:
    ssh         Create SSH keys for passwordless SSH between cluster nodes
    csync2      Configure csync2
    corosync    Configure corosync
    cluster     Bring the cluster online

If stage is not specified, each stage will be invoked in sequence.
END
	exit 0
}

init_ssh()
{
	start_service sshd

	invoke mkdir -m 700 -p /root/.ssh

	if [ -f /root/.ssh/id_rsa ]; then
		prompt_for_overwrite \
			'/root/.ssh/id_rsa already exists' || return
		invoke rm -f /root/.ssh/id_rsa
	fi

	status "Generating ssh key"
	invoke ssh-keygen -q -f /root/.ssh/id_rsa \
		-C 'Cluster Internal' -N '' \
		|| error "Failed to generate SSH key"
	append /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys
}

init_csync2()
{
	status "Configuring csync2"

	if [ -f "$CSYNC2_KEY" ] || \
		grep -v -q -s '^[[:space:]]*\(#.*\)*$' $CSYNC2_CFG
	then
		prompt_for_overwrite 'csync2 is already configured' || return
	fi

	invoke rm -f $CSYNC2_KEY
	status_long "Generating csync2 shared key (this may take a while)"
	# On a quiet VM, "a while" can be "way too long" (not enough entropy)
	invoke csync2 -k $CSYNC2_KEY || error "Can't create csync2 key $keyfile"
	status_done

	local tmp_conf=${CSYNC2_CFG}.$$
	cat > $tmp_conf <<END
group ha_group
{
	key /etc/csync2/key_hagroup;
	host $(hostname);
	include /etc/corosync/corosync.conf;
	include /etc/corosync/authkey;
	include /etc/csync2/csync2.cfg;
	include /etc/csync2/key_hagroup;
	include /etc/ctdb/nodes;
	include /etc/drbd.d;
	include /etc/ha.d/ldirectord.cf;
	include /etc/lvm/lvm.conf;
	include /etc/multipath.conf;
	include /etc/samba/smb.conf;
	include /etc/sysconfig/openais;
	include /etc/sysconfig/pacemaker;
	include /etc/sysconfig/sbd;
}
END
	install_tmp $tmp_conf $CSYNC2_CFG

	# Can't use start_service for csync2, because it runs inside xinetd
	status "Enabling csync2 service"
	invoke chkconfig csync2 on
	start_service xinetd

	status "csync2 checking files"
	invoke csync2 -cr /
}

# It would be nice if we could just have csync2.cfg include a directory,
# which in turn included one file per node which would be referenced via
# something like "group ha_group { ... config: /etc/csync2/hosts/*; }"
# That way, adding a new node would just mean adding a single new file
# to that directory.  Unfortunately, the 'config' statement only allows
# inclusion of specific individual files, not multiple files via wildcard.
# So we have this function which is called by hae-join to add the new
# remote node to csync2 config on some existing node.  It is intentionally
# not documented in hae-init's user-visible usage information.
init_csync2_remote()
{
	local newhost=$1
	local thishost=$(hostname)
	[ -n "$newhost" ] || error "Hostname not specified"

	BE_QUIET=true

	# If host doesn't already exist in csync2 config, add it
	if ! egrep -q -s \
		"^[[:space:]]*host.*[[:space:]]+${newhost}[[:space:];]" \
		$CSYNC2_CFG
	then
		local tmp_conf=${CSYNC2_CFG}.$$
		awk '/^[[:space:]]*host[[:space:]]/ \
			{ if (h==0) print "\thost '$newhost';"; h=1; } \
			{ print $0 } ' $CSYNC2_CFG > $tmp_conf
		install_tmp $tmp_conf $CSYNC2_CFG
		invoke csync2 -c $CSYNC2_CFG
	else
		log ": Nothing to do - remote host $newhost already exists"
	fi
}

init_corosync()
{
	if $YES_TO_ALL; then
		status 'Configuring corosync'
	else
		status "
Configure Corosync:
  This will configure the cluster messaging layer.  You will need
  to specify a network address over which to communicate (default
  is ${NET_IF}'s network, but you can use the network address of any
  active interface), a multicast address and multicast port.
"
	fi

	if [ -f "$COROSYNC_CONF" ]; then
		prompt_for_overwrite \
			"$COROSYNC_CONF already exists" || return
	fi

	local bindnetaddr=$(prompt_for_string \
		'Network address to bind to (e.g.: 192.168.1.0)' \
		'([0-9]+\.){3}[0-9]+' "$IP_NETWORK")
	[ -z "$bindnetaddr" ] && error 'No value for bindnetaddr'

	local mcastaddr=$(prompt_for_string \
		'Multicast address (e.g.: 239.x.x.x)' \
		'([0-9]+\.){3}[0-9]+' \
		239.$(random_256).$(random_256).$(random_256))
	[ -z "$mcastaddr" ] && error 'No value for mcastaddr'

	local mcastport=$(prompt_for_string \
		'Multicast port' \
		'[0-9]+' 5405);
	[ -z "$mcastport" ] && error 'No value for mcastport'

	local tmp_conf=${COROSYNC_CONF}.$$
	if grep -q -s '^[[:space:]]*name:[[:space:]]*pacemaker' ${COROSYNC_CONF}.example; then
		# "name: pacemaker" in corosync example conf is our assumption
		# that the example is sane, so use it:
		sed \
			-e 's/^\([[:space:]]*bindnetaddr:[[:space:]]*\).*/\1'$bindnetaddr'/' \
			-e 's/^\([[:space:]]*mcastaddr:[[:space:]]*\).*/\1'$mcastaddr'/' \
			-e 's/^\([[:space:]]*mcastport:[[:space:]]*\).*/\1'$mcastport'/' \
			/etc/corosync/corosync.conf.example > $tmp_conf
	else
		# Fallback to known sane config (defaults from SLE 11 SP1 HAE
		# corosync.conf.example.patch)
		cat > $tmp_conf <<END
# Please read the corosync.conf.5 manual page
compatibility: whitetank
aisexec {
	group:		root
	user:		root
}
service {
	ver:		0
	name:		pacemaker
	use_mgmtd:	yes
	use_logd:	yes
}
totem {
	version:	2
	token:		5000
	token_retransmits_before_loss_const: 10
	join:		60
	consensus:	6000
	vsftype:	none
	max_messages:	20
	clear_node_high_bit: yes
	secauth:	off
	threads:	0
	interface {
		ringnumber:	0
		bindnetaddr:	$bindnetaddr
		mcastaddr:	$mcastaddr
		mcastport:	$mcastport
	}
}
logging {
	fileline:	off
	to_stderr:	no
	to_logfile:	no
	timestamp:	on
	to_syslog:	yes
	syslog_facility: daemon
	debug:		off
	timestamp:	off
}
amf {
	mode:	disable
}
END
	fi
	install_tmp $tmp_conf $COROSYNC_CONF
	invoke csync2 -xv $COROSYNC_CONF
}

init_cluster()
{
	init_cluster_local

	local -i node_count=$(crmadmin -N|grep 'node'|wc -l)
	[ "$node_count" -lt 1 ] && error "No nodes found in cluster"
	[ "$node_count" -gt 1 ] && error "Joined existing cluster - will not reconfigure."

	status "Loading initial configuration"
	local tmp_conf=/tmp/crm.$$
	cat > $tmp_conf <<END
property \$id="cib-bootstrap-options" \\
	stonith-enabled="true" \\
	no-quorum-policy="ignore" \\
	placement-strategy="balanced"
op_defaults \$id="op-options" \\
	timeout="600" \\
	record-pending="true"
rsc_defaults \$id="rsc-options" \\
	resource-stickiness="1" \\
	migration-threshold="3"
END
	crm_configure_load replace $tmp_conf
}

#------------------------------------------------------------------------------

while getopts 'hi:qy' o; do
	case $o in
	h) usage;;
	i) NET_IF=$OPTARG;;
	q) BE_QUIET=true;;
	y) YES_TO_ALL=true;;
	esac
done

shift $(($OPTIND - 1))

if [ "$1" != "ssh" -a "$1" != "csync2_remote" ]; then
	rcopenais status >/dev/null
	rc=$?
	[ $rc -eq 0 ] && error "Cluster is currently active - can't run"
	[ $rc -ne 7 ] && error "rcopenais status returned unexpected status ($rc)"
fi

case $1 in
ssh|csync2|csync2_remote|corosync|cluster)
	log_start
	# $2 == nasty hack to pick up IP arg to csync2_remote
	init_$1 $2
	;;
"")
	log_start
	init_ssh
	init_csync2
	init_corosync
	init_cluster
	;;
*)	echo -e "Invalid stage ($1)\n"
	usage
esac

status "Done"
exit 0
