#!/bin/bash
#
# Copyright (c) 2010 Novell Inc., Tim Serong <tserong@novell.com>
#                        All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
#

declare -r LOG_FILE=/var/log/hae-bootstrap.log

# Broken out as special case for log() failure.  Ordinarily you
# should just use error() to terminate.
_die()
{
	echo "ERROR: $1" >&2
	exit 1
}

error()
{
	log "ERROR: $1"
	_die $1
}

log()
{
	echo $1 >> $LOG_FILE || _die "Can't append to $LOG_FILE - aborting"
}

# Execute something and log it same as "set -x" would do (so you can see
# stdout and stderr from invoked command, and can also copy the command
# itself from the log file and execute manually later if necessary). 
invoke()
{
	local rc

	echo + $(printf '%q ' "$@") >> $LOG_FILE

	set -f
	"$@" >> $LOG_FILE 2>&1
	rc=$?
	set +f

	return $rc
}

start_service()
{
	invoke chkconfig $1 on
	rc$1 status >/dev/null
	if [ $? -ne 0 ]; then
		invoke rc$1 start
		[ $? -ne 0 ] && error "Failed to start $1 service"
	fi
}

# Interactive, but because it's in a function we can easily add a
# "yes-to-all" flag later
prompt_for_overwrite()
{
	local tmp
	read -e -p "  $1 - overwrite? [y/N] " tmp
	[ "$tmp" != "y" -a "$tmp" != "Y" ] && return 1
	return 0
}

# TODO: is there a better way to do this?  I just want to log
# the "cat >>" nicely...
append()
{
	log "+ cat $1 >> $2"
	cat $1 >> $2
}

_onexit()
{
	local rc=${1:-$?}
	log '----------------------------------------------------------------'
	log "$(date --rfc-3339=seconds) exited (rc=$rc)"
	log '================================================================'
	# don't double-trap on normal exit
	trap - 0
	exit $rc
}

log_start()
{
	# Convenient side-effect: this will die immediately if the log file
	# is not writable (e.g. if not running as root)
	log '================================================================'
	log "$(date --rfc-3339=seconds) $0 $*"
	log '----------------------------------------------------------------'

	# Now that we know we have at least some chance of running, catch
	# all the interesting signals so we can terminate the log neatly.
	trap _onexit 0 1 2 3 10 12 13 14 15
}
