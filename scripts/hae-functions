#!/bin/bash
#
# Copyright (c) 2010 Novell Inc., Tim Serong <tserong@novell.com>
#                        All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
#

declare -r INVOCATION="$0 $*"
declare -r LOG_FILE=/var/log/hae-bootstrap.log
declare -r CSYNC2_KEY=/etc/csync2/key_hagroup
declare -r CSYNC2_CFG=/etc/csync2/csync2.cfg
declare -r COROSYNC_CONF=/etc/corosync/corosync.conf

declare BE_QUIET=false
declare YES_TO_ALL=false
declare NET_IF=eth0
declare IP_ADDRESS
declare IP_NETWORK

# Broken out as special case for log() failure.  Ordinarily you
# should just use error() to terminate.
_die()
{
	echo "ERROR: $@" >&2
	exit 1
}

error()
{
	log "ERROR: $@"
	_die $@
}

warn()
{
	log "WARNING: $@"
	echo "WARNING: $@" >&2
}

log()
{
	echo $@ >> $LOG_FILE || _die "Can't append to $LOG_FILE - aborting"
}

# Execute something and log it same as "set -x" would do (so you can see
# stdout and stderr from invoked command, and can also copy the command
# itself from the log file and execute manually later if necessary). 
invoke()
{
	local rc

	echo + $(printf '%q ' "$@") >> $LOG_FILE

	set -f
	"$@" >> $LOG_FILE 2>&1
	rc=$?
	set +f

	return $rc
}

start_service()
{
	status "Enabling $1 service"

	invoke chkconfig $1 on
	rc$1 status >/dev/null
	if [ $? -ne 0 ]; then
		invoke rc$1 start
		[ $? -ne 0 ] && error "Failed to start $1 service"
	fi
}

status()
{
	$BE_QUIET && return
	echo "$1"
}

status_long()
{
	$BE_QUIET && return
	echo -n "$1..."
}

status_done()
{
	$BE_QUIET && return
	echo "done"
}

prompt_for_overwrite()
{
	$YES_TO_ALL && return 0

	local tmp
	read -e -p "  $1 - overwrite? [y/N] " tmp
	[ "$tmp" != "y" -a "$tmp" != "Y" ] && return 1
	return 0
}

prompt_for_string()
{
	local msg=$1
	local match=$2
	local default=$3
	local val
	local tmp

	if $YES_TO_ALL; then
		# Warning: this will return an empty string if
		# there's no default - callers be prepared!
		echo $default
		return
	fi

	while [ -z "$val" ]; do
		read -e -p "  $msg [$default] " tmp
		[ -n "$tmp" ] && default=$tmp
		[[ "$default" =~ $match ]] && val=$default \
			|| echo "    Invalid value entered" >&2
	done

	echo $default
}

install_tmp()
{
	log ": created $1 with content:"
	cat $1 >> $LOG_FILE
	invoke sync
	invoke mv -f $1 $2
	[ $? -ne 0 ] && error "Failed to install $2 (temp is $1)"
}

random_256()
{
	local -i n=$RANDOM
	let 'n %= 256'
	echo $n
}

# TODO: is there a better way to do this?  I just want to log
# the "cat >>" nicely...
append()
{
	log "+ cat $1 >> $2"
	cat $1 >> $2
}

_onexit()
{
	local rc=${1:-$?}
	log '----------------------------------------------------------------'
	log "$(date --rfc-3339=seconds) exited (rc=$rc)"
	log '================================================================'
	# don't double-trap on normal exit
	trap - 0
	exit $rc
}

log_start()
{
	# Convenient side-effect: this will die immediately if the log file
	# is not writable (e.g. if not running as root)
	log '================================================================'
	log "$(date --rfc-3339=seconds) $INVOCATION"
	log '----------------------------------------------------------------'

	# Now that we know we have at least some chance of running, catch
	# all the interesting signals so we can terminate the log neatly.
	trap _onexit 0 1 2 3 10 12 13 14 15

	# log_start() is a bit of a misnomer, we also set up some globals...

	# Auto-detection of IP address and netmask only works if $NET_IF is
	# up. If $IP_ADDRESS is overridden, network detect shouldn't work,
	# because "ip route" won't be able to help us.
	if [ -z "$IP_ADDRESS" ]; then
		IP_ADDRESS=$(ip -o -f inet addr show | \
			awk "/[[:space:]]${NET_IF}[[:space:]]/ {print \$4} " |
			sed 's/\/[1-9][1-9]//')
	fi
	if [ -z "$IP_NETWORK" -a -n "$IP_ADDRESS" ]; then
		IP_NETWORK=$(ip route list | \
			awk "/${IP_ADDRESS}/ { print \$1; }" |
			sed 's/\/[1-9][1-9]//')
	fi

	[ -z "$IP_ADDRESS" ] && \
		warn "Could not detect IP address for $NET_IF"
	[ -z "$IP_NETWORK" ] && \
		warn "Could not detect network address for $NET_IF"
}
